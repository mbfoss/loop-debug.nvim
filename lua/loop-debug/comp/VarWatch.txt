local class             = require('loop.tools.class')
local ItemTreeComp      = require('loop.comp.ItemTree')
local strtools          = require('loop.tools.strtools')

---@alias loopdebug.comp.VarWatch.Item loop.comp.ItemTree.Item

---@class loopdebug.comp.VarWatch : loop.comp.ItemTree
---@field new fun(self: loopdebug.comp.VarWatch, name:string): loopdebug.comp.VarWatch
local VarWatch          = class(ItemTreeComp)

local _vartype_to_group = {
    -- primitives
    ["string"]     = "@string",
    ["number"]     = "@number",
    ["boolean"]    = "@boolean",
    ["null"]       = "@constant.builtin",
    ["undefined"]  = "@constant.builtin",
    -- functions
    ["function"]   = "@function",
    ["function()"] = "@function", -- seen in some DAP servers
    ["function "]  = "@function",
    ["func"]       = "@function",
    ["Function"]   = "@function",
    -- objects / tables / arrays
    ["array"]      = "@structure",
    ["list"]       = "@structure",
    ["table"]      = "@structure",
    ["object"]     = "@structure",
    ["Object"]     = "@structure",
    ["Array"]      = "@structure",
    ["Module"]     = "@module",
}

---@param vartype string
---@return string|nil
function _get_vartype_hightlight(vartype)
    if not vartype then return nil end
    vartype = tostring(vartype)
    vartype = vartype:gsub("%s+", "")
    vartype = vartype:lower()
    local hl = _vartype_to_group[vartype]
    return hl or "@variable"
end

---@param id any
---@param data any
---@param highlights loop.comp.ItemTree.Highlight
---@return string
local function _variable_node_formatter(id, data, highlights)
    if not data then return "" end
    if data.greyout then
        table.insert(highlights, { group = "NonText" })
    else
        local valuehl = data.is_na_value and "NonText" or _get_vartype_hightlight(data.type)
        table.insert(highlights, { group = "@symbol", start_col = 0, end_col = #data.name })
        table.insert(highlights, { group = valuehl, start_col = #data.name + 2 })
    end
    return tostring(data.name) .. ": " .. tostring(data.value)
end

local function floating_input_at_cursor(opts)
    local prev_win = vim.api.nvim_get_current_win()
    -- Create scratch buffer
    local buf = vim.api.nvim_create_buf(false, true)
    vim.bo[buf].buftype = "nofile"
    vim.bo[buf].bufhidden = "wipe"
    vim.bo[buf].buftype = "nofile"
    vim.bo[buf].swapfile = false
    vim.bo[buf].undolevels = -1
    -- Cursor position
    -- Floating window at current line
    local win = vim.api.nvim_open_win(buf, true, {
        relative = "cursor",
        row = opts.row_offset,
        col = opts.col_offset,
        width = opts.width,
        height = 1,
        style = "minimal",
        border = "rounded",
    })
    vim.wo[win].winhighlight = "Normal:Normal,NormalNC:Normal,EndOfBuffer:Normal,FloatBorder:Normal"
    vim.api.nvim_set_current_win(win)
    vim.api.nvim_buf_set_lines(buf, 0, -1, false, { opts.default })
    vim.api.nvim_win_set_cursor(win, { 1, #opts.default })
    vim.cmd("normal! q")
    vim.cmd("startinsert")
    local closed = false
    local function close(value)
        if closed then return end
        closed = true
        vim.cmd("stopinsert")
        vim.api.nvim_set_current_win(prev_win)
        if vim.api.nvim_win_is_valid(win) then
            vim.api.nvim_win_close(win, true)
        end
        vim.schedule(function() opts.on_confirm(value) end)
    end
    -- Confirm on Enter
    vim.keymap.set("i", "<CR>", function()
        local line = vim.api.nvim_get_current_line()
        close(line ~= "" and line or nil)
    end, { buffer = buf, nowait = true })
    -- Cancel on Esc
    vim.keymap.set("i", "<Esc>", function() close(nil) end, { buffer = buf, nowait = true })
    vim.api.nvim_create_autocmd("WinLeave", {
        once = true,
        callback = function()
            close(nil)
        end,
    })
end

function VarWatch:init()
    ItemTreeComp.init(self, {
        formatter = _variable_node_formatter,
    })
    ---@type string[]
    self._watch_exressions = {}
    self._cur_data_provider = nil
    ---@type loopdebug.proto.StackFrame
    self._cur_frame = nil
    ---@type table<any,boolean> -- id --> expanded
    self._layout_cache = {}

    self:_load_expressions()
end

---@param comp loop.BufferController
function VarWatch:link_to_buffer(comp)
    ItemTreeComp.link_to_buffer(self, comp)

    --- Helper: edit an existing watch or add a new one
    local function add_watch()
        local win = vim.api.nvim_get_current_win()
        local cursor = vim.api.nvim_win_get_cursor(win)
        local col_offset = -cursor[2]
        local row_offset = 0
        floatwin.input_at_cursor({
            row_offset = row_offset,
            col_offset = col_offset,
            width = 30,
            default = "",
            on_confirm = function(expr)
                if not expr then return end
                -- Remove from _watch_expressions
                local exists = false
                for i, curexpr in ipairs(self._watch_exressions) do
                    if expr == curexpr then
                        exists = true
                        break
                    end
                end
                if not exists then
                    table.insert(self._watch_exressions, expr)
                end
                self:_load_expr_value(expr)
            end
        })
    end

    -- Add keymaps
    comp.add_keymap("i", {
        desc = "Add watch (inline)",
        callback = function() add_watch() end,
    })

    comp.add_keymap("d", {
        desc = "Delete watch",
        callback = function()
            ---@type loop.comp.ItemTree.Item|nil
            local cur_item = self:get_cur_item(comp)
            if not cur_item then return end
            -- Remove from _watch_expressions
            for i, expr in ipairs(self._watch_exressions) do
                if expr == cur_item.data.name then
                    table.remove(self._watch_exressions, i)
                    break
                end
            end
            -- Remove from tree cache
            self._layout_cache[cur_item.id] = nil
            self:remove_item(cur_item.id)
        end,
    })
end

---@param data_provider loopdebug.session.DataProviders
---@param ref number
---@param parent_id number|string
---@param callback fun(items:loopdebug.comp.Variables.Item[])
function VarWatch:_load_variables(data_provider, ref, parent_id, callback)
    data_provider.variables_provider({ variablesReference = ref },
        function(_, vars_data)
            local children = {}
            if vars_data then
                for _, var in ipairs(vars_data.variables) do
                    local item_id = parent_id .. strtools.special_marker1() .. var.name
                    ---@type loopdebug.comp.Variables.Item
                    local var_item = {
                        id = item_id,
                        parent_id = parent_id,
                        expanded = self._layout_cache[item_id],
                        data = {
                            name = var.name,
                            type = var.type,
                            value = var.value
                        },
                    }
                    if var.variablesReference and var.variablesReference > 0 then
                        var_item.children_callback = function(cb)
                            if var_item.data.greyout then
                                cb({})
                            else
                                self:_load_variables(data_provider, var.variablesReference, item_id, cb)
                            end
                        end
                    end
                    table.insert(children, var_item)
                end
            end
            callback(children)
        end)
end

function VarWatch:_load_expressions()
    ---@type loop.comp.ItemTree.Item[]
    for _, expr in ipairs(self._watch_exressions) do
        self:_load_expr_value(expr)
    end
end

---@param expr string
function VarWatch:_load_expr_value(expr)
    ---@type loopdebug.comp.Variables.Item
    local var_item = {
        id = expr,
        parent_id = nil,
        expanded = self._layout_cache[expr],
        data = { is_expr = true, name = expr }
    }
    if not self._cur_data_provider or not self._cur_frame then
        ---@diagnostic disable-next-line: undefined-field
        var_item.id = "na_" .. vim.loop.hrtime()
        var_item.data.value = "not available"
        var_item.data.is_na_value = true
        self:upsert_item(var_item)
        return
    end
    self._cur_data_provider.evaluate_provider({
        expression = expr,
        frameId = self._cur_frame.id,
        context = 'watch',
    }, function(err, data)
        if err or not data then
            var_item.data.value = "not available"
            var_item.data.is_na_value = true
        else
            var_item.data.value = data.result
            if data.variablesReference and data.variablesReference > 0 then
                var_item.children_callback = function(cb)
                    if var_item.data.greyout then
                        cb({})
                    else
                        self:_load_variables(self._cur_data_provider, data.variablesReference, var_item.id, cb)
                    end
                end
            end
        end
        self:upsert_item(var_item)
    end)
end

---@param data_provider loopdebug.session.DataProviders
---@param frame loopdebug.proto.StackFrame
function VarWatch:update_data(data_provider, frame)
    self._cur_data_provider = data_provider
    self._cur_frame = frame
    self:_load_expressions()
end

function VarWatch:greyout_content()
    local items = self:get_items()
    for _, item in ipairs(items) do
        item.data.greyout = true
        self._layout_cache[item.id] = item.expanded
    end
    self:refresh_content()
end

return VarWatch
